---
title: '前端一揽子精选文章'
date: '2022-01-11'
tags: 'others' 
---


### JS作用域

https://juejin.cn/post/6844903797135769614

#### **深入理解JavaScript作用域和作用域链** 

简单概述：电面提的问题没回答上来的一个知识点。

**作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性**

#### 三大作用域

1.**块级**作用域（ES6 新增`let/const`实现）

**块语句（大括号“｛｝”中间的语句）**

自从有了 `let` 以后块里面的变量就只能真的在块里了

```js
{
  let a='nihao2022';
  console.log(a); //output:nihao2022
}
console.log(a) //a是没有被定义的 找不到a
```

而`var` 这个老的变量定义方式 还是可以冲破这个限制的,块限制不住它,作用域大于块

```js
if (true) {
     //'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

2.**全局**作用域 :主要还是暴露在最外层的所有定义 ,都是全局的 ,然后几乎哪都能get到这些函数/变量，都有权限访问到这些被全局声明的

3.**局部**作用域

也称之为**函数作用域** 在一个函数里定义的 外边是访问不到函数里面定义的变量的



#### PS

牵扯到面试另一个没回答的问题，IIFE立即执行`(()=>{})()` 这个可以很好地封闭函数里的变量不被污染 外边是访问不到内部的变量的,现代工具库喜欢弄这个，jq就是这样的。

**for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。**

```js
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

**1.  js引擎子作用域优先 输出abc说明循环体内部是子作用域** 

**2.  i 可以被 `let` 两次说明分属两个作用域**

（ **let 不能在同一作用域内重复声明一个已有标识符**：会报错）

#### 作用域链

就是使用一个变量但本作用域无此变量（即自由变量） 就像链上寻找（父级）之类的 

特殊：在函数里找父级链上变量是基于**定义时**的作用域（称之为静态作用域）

```js
var x=100;
const f1=()=>{
	console.log(x);
}
const f2=()=>{
	let x=999;
	f1();
}
f2(); //输出100
```

**与调用时作用域无关/与定义时作用域相关**

原理：js的运行机制时**解释+执行** 解释时就已经确定了作用域！！！！！

执行时自然按照解释后的作用域来执行（this的指向是执行时确定的，而作用域访问的变量是编写代码的结构确定的）